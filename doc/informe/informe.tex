\documentclass[10pt, a4paper]{article}

\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{footnote}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{pdflscape}

\usepackage{pdfpages}

\usepackage{caratula}


\materia{Ingeniería de Software II}

\titulo{Trabajo Práctico 1}
\subtitulo{Sprint Planning}

\integrante{Martín Alejandro Miguel}{181/09}{m2.march@gmail.com}
\integrante{Iván Postolski}{216/09}{ivan.postolski@gmail.com}
\integrante{Juan Manuel Martinez Caamaño}{276/09}{jmartinezcaamao@gmail.com}
\integrante{Matías Incem}{396/09}{matias.incem@gmail.com}
\integrante{Pablo Gauna}{334/09}{gaunapablo@gmail.com}


\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introducción}

El actual informe presenta el análisis, diseño y desarrollo inicial realizado para el producto \textbf{Precio Justo}. En el mismo se detallan el conjunto de \emph{user stories} que abarcan el desarrollo completo de la aplicación, incluyendo tanto las definiciones actuales como los puntos de extensión que se tendrán en cuenta. Se presenta además un primer \emph{diseño orientado a objetos} de la aplicación completa. Este tiene como intención estar abierto a los distintos ejes de cambios considerados en esta instancia. Por último, se analiza el alcance, el proceso y el éxito de la primera iteración del proceso de desarrollo. En esta sección se explica lo logrado y se generan conclusiones y propuestas de cambio para el resto del proceso.

\section{Análisis de la aplicación}

\subsection{Objetivo}

\textbf{Precio Justo} es una aplicación de recolección y procesamiento de datos masivos provistos por redes sociales. La intención es poder recopilar los precios más baratos para ciertos productos, de forma confiable y libre de intereses particulares. La elección del uso de las redes sociales para obtener los datos tiene como objetivo lograr imparcialidad en los mismos.

\subsection{Ejes de cambio}

Dentro de la resolución del objetivo de la aplicación se establecen, para una primera instancia, las siguientes restricciones, que pasan a conformar \emph{ejes de cambio} de la aplicación:

\paragraph{Obtención de datos}
\begin{itemize}
    \item \textbf{Origen de los datos:} En un primer lugar los datos a utilizar por la aplicación se obtendrán exclusivamente de \emph{twitter}. Dentro del flujo de datos del mismo, se espera filtrar aquellos que contengan información relevante para nuestros propósitos.
    \item \textbf{Formato de los tweets:} Considerando la restricción anterior, debe definirse bajo qué criterio un \emph{tweet} es útil. En una primera instancia se espera que los mismos tengan un formato similar a \textsf{$<$Producto$>$ $<$Precio$>$ $<$Unidad$>$ $<$Lugar$>$ \#PrecioJusto}, donde el \emph{hashtag} es indicador de que el \emph{tweet} está orientado a ser utilizado por nuestra aplicación. Se espera en un futuro poder precindir del \emph{hashtag} y poder interpretar formatos más flexibles.
    \item \textbf{Unidad de los productos:} Otra restricción impuesta para el procesamiento de datos es que los precios estén indicados en su valor por una cierta unidad, siendo restringida las unidades aceptadas para cada producto. Por ejemplo, para tomates se aceptan solo \emph{kilogramos}, y para aceite la \emph{unidad}.
    \item \textbf{Correctitud de los datos:} Una restricción implícita existente es que los mensajes a leer están bien escritos. Otra arista de cambio para la aplicación es poder soportar un cierto nivel de errores tipográficos en nuestra fuente cruda de datos.
\end{itemize}

\paragraph{Productos soportados}
Inicialmente la aplicación tendrá soporte para una cantidad limitada de productos, enfocándose principalmente en aquellos de primera necesidad. La misma debe ser suficientemente flexible para poder cambiar estos productos. 

\paragraph{Ubicación}
La aplicación debe informar el lugar donde puede comprarse el producto al precio establecido. Inicialmente esta información deberá estar presente en el mismo \emph{tweet} en formato de 'calle y altura'. Conciendo que \textbf{twitter} permite agregar como información del \emph{tweet} la posición geográfica del mismo, esta información podría utilizarse en reemplazo del texto explicitando la dirección. Se espera que la aplicación pueda usar estos datos. 

Por otra parte, es importante tener en cuenta que, de agregarse nuevas fuentes de datos a la aplicación, estas deben ser capaces de indicar dónde se consigue el producto al precio publicitado.

\paragraph{Resumen de la información}
Dentro de la definición de la aplicación se establece que debe permitírsele al usuario especificar como la información será tratada. En esto se definen las siguientes características.

\begin{itemize}
  \item \textbf{Resumen:} Dentro de la masividad de datos que tendremos para un producto, es necesario definir como estos se resumirán para el usuario. En primer lugar, se deben poder priorizar los precios más baratos. Además se definen otras estrategias para tratar los datos como ser \emph{caminando lo menos posible}. El sistema debe permitir agregar nuevas estrategias fácilmente.
  \item \textbf{Filtrado:} Otra posibilidad de tratamiento de datos que se le ofrece al usuario es el filtrado de los mismos. En este momento se presentan dos filtros: por zona geográfica y por rango de precios. El sistema debe soportar agregar nuevos criterios fácilmente.
  \item \textbf{Productos:} En esta primera instancia de la aplicación se está poniendo como restricción que el usuario pueda elegir un solo producto para buscar. En la versión final, la aplicación debe permitirle hacer búsquedas de varios productos a la vez.
\end{itemize}

\paragraph{Veracidad de los datos} A pesar del supuesto donde los datos provistos por redes sociales son imparciales, esto no nos asegura que los datos sean siempre correctos. Es importante tener en cuenta que los precios suben o que algún precio reportado puede ser una oferta temporal. Para tratar con estas complejidades se decidió que el sistema deberá incorporar en un futuro una forma de especificar la vigencia del precio en caso de ser una oferta. En una primera instancia, la aplicación se compromente a utilizar solo datos que tengan una frescura suficiente de forma que puedan considerarse correctos.

Otra propuesta para esta temática es incrementar la interacción con el usuario y que este pueda votar o reportar las ofertas provistas según si fueron buenas o no. Este tipo de información nos permitiria eliminar datos falsos o desactualizados.

\paragraph{Presentación de los datos}
La visualización de ofertas que se le dará al usuario no se encuentra completamente definida en esta instancia, es por ello que el diseño debe ser capaz de adaptarse a distintas propuestas que puedan surgir en el mediano plazo. Una propuesta ya presente es que la aplicación incorpore la información de precios en un mapa.


\section{User Stories}

\include{userStories}

\section{Diseño}

La aplicación desarrollada se descompone en dos componentes, un \emph{Frontend}, a travez del cual el usuario accede a los servicios del sistema y se concentra en la presentación de la información, y un \emph{Backend}, al cual se le delegan las tareas de, a partir de una entrada del usuario, construir un resultado y comunicarselo al Frontend. En las siguientes secciones pasaremos a presentar en detalle el diseño del sistema.

\subsection{Diagramas de clases}
  
A continuación detallaremos el diseño del Frontend. Dado que nos encontramos en la primer iteración del proceso de desarrollo, el foco se concentro en proveer una interfaz clara para comunicar el Frontend con el Backend, y no una implementación completa de la capa de presentación de los datos.

La clase \textbf{WebFrontend} es la encargada de la presentación de los datos. Esta clase posee un unico metodo utilizado por la libreria \emph{CherryPy} para la presentación  al usuario. La capa de presentación de los datos se encuentra lo suficientemente desacoplada de la capa de comunicación con el Backend, de forma que el cambiar por completo la presentación no debería afectar la comunicación con el Backend.

La clase \textbf{OfferBackend} representa al Backend de la aplicación, con el cual el Frontend se comunica. Se decidio que esta clase debe ser \emph{abstracta} debido a que podrian haber varios metodos de comunicación con el Backend (Por ejemplo, mediante un servicio REST, de forma local, etc...). Son las subclases de OfferBackend las encargadas de definir esta cuestion. Un caso particular de esto es \textbf{OfferRestBackend}, que utiliza REST para comunicarse con el Backend. 

La clase \emph{RestCommunicator} provee una interfaz con la cual comunicarnos con un servicio REST como el implementado. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/frontend_class.jpg}
\caption{Frontend}
\end{figure}

linea1\\
linea2\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{graphics/model_manager_iterable_class.jpg}
\caption{Model Manager Iterable}
\end{figure}

\newpage
linea1\\
linea2\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/model_manager_storeObject_class.jpg}
\caption{Model Manager StoreObject}
\end{figure}

\newpage
Para pasar de los Twits (u otro medio, ya que en este punto es transparente el origen de la información) a ofertas entendibles en nuestro sistema. Implementamos un \textbf{OfferFactory} el cual es capas de tranformar una lista de twits (validos o no) en una lista de offertas validas.\\

Para esto el OfferFactory es inicializado con un \textbf{ParserChain} que se encarga de intentar parsear la informacion de los twits devolviendo como resultado un \textbf{OfferBuilder} o la excepcion  \textbf{ParserError} en caso de no ser posible para el parser extrar la informacion para rellenar el OfferBuilder.\\

El ParserChain es Inicializado con una lista de \textbf{SpecificParser}, los cuales son llamados en el orden en el que vienen en la lista, tratando de extrar la informacion que necesitan y volcandola dentro del OfferBuilder que se esta rellenado.\\

Este diseño nos da una gran flexibilidad para los cambios futuros, tanto en agregar nuevas formas de extraer datos, como tambien alterar la forma en la que se extraen los dados ahora sin modificar otras.\\

Como por ejemplo seria muy facil agregar el validador ortografico para poder detectar productos mal escritos sin necesidad de alterar nunguna otra parte (en el diseño se muestra una clase tentativa que le agrega a \textbf{ProductParser} la posibilidad de chequear esto).\\

Lo mismo se aplica con la posibilidad de agregar validaciones a la \textbf{Location} la cual por el momento solo consiste en un string que no tiene ningun tipo de chequeo sobre su validez.\\



\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{graphics/parser_class.jpg}
\caption{Offer Factory}
\end{figure}
\begin{landscape}

\newpage
En este diagrama se destacan las clases de objetos que se encargan de, dada una \textbf{OfferQueryInConstruction} (Objeto que representa una consulta por ofertas sin procesar), construyen el conjunto de restricciones a aplicar sobre las ofertas. Son los objetos de tipo \textbf{QueryProcessor} los encargados de construir los \textbf{Filter} y \textbf{Strategy} que determinan los resultados de la consulta. En caso de que alguno de los parametros introducido por el usuario no sea valido, el \textbf{QueryProcessor} correspondiente informara de esta situación mediante una excepción. La clase \textbf{QueryProcessor} y sus subclases, siguen el patron de diseño \emph{Composite}.

Los objetos de tipo \textbf{ValidProductsProvider} llevan cuenta de cuales son los productos validos. Un objeto de este tipo es utilizado por un \textbf{ProductQueryProcessor} para verificar que el producto ingresado por el usuario se encuentre en la lista de los productos soportados por el sistema.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{graphics/queryProcessor_class.jpg}
\caption{Query Processor}
\end{figure}

\newpage
Como fue mencionado anteriormente, un objeto de tipo \textbf{OfferQueryInConstruction} representa una query del usuario, la cual todavia no se termino de procesar (Construir los filtros y estrategias correspondientes). Una vez que se terminaron de construir los filtros y estrategias correspondientes a la consulta del usuario, es necesario hacerla inmutable, obteniendo asi un objeto con tipo \textbf{OfferQuery}. Los objetos de esta clase poseen unicamente un \textbf{Filter} y una \textbf{Strategy}.

Las \textbf{Strategy} representan distintas politicas para priorizar ofertas, por ejemplo, \emph{Mas baratas primero}.
Los \textbf{Filter} representan condiciones booleanas que deben cumplir las ofertas para poder encontrarse en el conjunto de resultado. La clase \textbf{Filter} cumple con el patron de diseño \emph{Composite}. La clase \textbf{MultiFilter} sigue el patron \emph{TemplateMethod}, esta clase define un esqueleto para la función \emph{filter}, sin embargo, son las clases derivadas las que implementan los metodos \emph{reduceOp} y \emph{baseCase}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{graphics/filter_class.jpg}
\caption{Filter}
\end{figure}



\newpage
\subsection{Diagramas de secuencias}
linea1\\
linea2\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/andFilter_sequence.jpg}
\caption{andFilter}
\end{figure}
\newpage
linea1\\
linea2\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.70]{graphics/service_sequence.jpg}
\caption{Service}
\end{figure}
\newpage
linea1\\
linea2\\
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{graphics/OfferFactory_sequence.jpg}
\caption{Offer Factory}
\end{figure}

\end{landscape}

\section{Primera Iteración}

En un esquema de desarrollo iterativo incremental, el producto final se construye en iteraciones. En cada iteración se establecen ciertos objetivos, que apuntan a agregar una nueva funcionaliad al producto. Para el momento de este informe, se desarrolló solo la primera iteración. En la misma, el objetivo definido fue tener una primera versión de la aplicación con una funcionalidad limitada, pero completa frente al espíritu del proyecto. El resultado de una iteración se denomina \emph{product increment}. En el \emph{product increment} se deberá permitir buscar las ofertas de un producto en \emph{twitter}, filtrarlos con algún criterio y priorizalos mediante alguna estrategia.

A continuación explicamos como resulto el desarrollo de la primera iteración.

\subsection{Desarrollo}

En el ámbito del trabajo que se está realizando, es importante remarcar el hecho que el desarrollo iterativo incremental de la aplicación fue en el marco de un trabajo práctico cuyos objetivos exceden (en incluso son conflictivos con) los objetivos normales de una iteración. 

\begin{figure}[H]
\centering
\includegraphics[scale=1.2]{graphics/iteration_burndown.pdf}
\caption{\textbf{Burndown chart:} progreso de terminación de tareas en el \emph{sprint}.}
\end{figure}

\subsection{Logros}

\subsection{Review}

\end{document}
