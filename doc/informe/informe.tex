\documentclass[10pt, a4paper]{article}

\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{footnote}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{pdflscape}

\usepackage{pdfpages}

\usepackage{caratula}
\usepackage{userStories}

\materia{Ingeniería de Software II}

\titulo{Trabajo Práctico 1}
\subtitulo{Sprint Planning}

\integrante{Martín Alejandro Miguel}{181/09}{m2.march@gmail.com}
\integrante{Iván Postolski}{216/09}{ivan.postolski@gmail.com}
\integrante{Juan Manuel Martinez Caamaño}{276/09}{jmartinezcaamao@gmail.com}
\integrante{Matías Incem}{396/09}{matias.incem@gmail.com}
\integrante{Pablo Gauna}{334/09}{gaunapablo@gmail.com}


\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introducción}

El actual informe presenta el análisis, diseño y desarrollo inicial realizado para el producto \textbf{Precio Justo}. En el mismo se detallan el conjunto de \emph{user stories} que abarcan el desarrollo completo de la aplicación, incluyendo tanto las definiciones actuales como los puntos de extensión que se tendrán en cuenta. Se presenta además un primer \emph{diseño orientado a objetos} de la aplicación completa. Este tiene como objetivo ser expansible respecto de los distintos ejes de cambios considerados para esta instancia. Por último, se analiza el alcance, el proceso y el éxito de la primera iteración del proceso de desarrollo. 

\section{Análisis de la aplicación}

\subsection{Objetivo}

\textbf{Precio Justo} es una aplicación de recolección y procesamiento de datos masivos provistos por redes sociales. La intención es poder recopilar los precios más baratos para ciertos productos, de forma confiable y libre de intereses particulares. La elección del uso de las redes sociales para obtener los datos tiene como objetivo lograr imparcialidad en los mismos.

\subsection{Ejes de cambio}

Dentro de la resolución del objetivo de la aplicación se establecen, para una primera instancia, las siguientes restricciones, que pasan a conformar \emph{ejes de cambio} de la aplicación:

\paragraph{Obtención de datos}
\begin{itemize}
    \item \textbf{Origen de los datos:} En un primer lugar los datos a utilizar por la aplicación se obtendrán exclusivamente de \emph{twitter}. Dentro del flujo de datos del mismo, se espera filtrar aquellos que contengan información relevante para nuestros propósitos.
    \item \textbf{Formato de los tweets:} Considerando la restricción anterior, debe definirse bajo qué criterio un \emph{tweet} es útil. En una primera instancia los mismos deberán tener un formato similar a \textsf{$<$Producto$>$ $<$Precio$>$ $<$Unidad$>$ $<$Lugar$>$ \#PrecioJusto}, donde el \emph{hashtag} es indicador de que el \emph{tweet} está orientado a ser utilizado por nuestra aplicación. Se espera en un futuro poder precindir del \emph{hashtag} y poder interpretar formatos más flexibles.
    \item \textbf{Unidad de los productos:} Otra restricción impuesta para el procesamiento de datos es que los precios estén indicados en su valor por una cierta unidad, siendo restringida las unidades aceptadas para cada producto. Por ejemplo, para tomates se aceptan solo \emph{kilogramos}, y para leche el \emph{litro}.
    \item \textbf{Correctitud de los datos:} Una restricción implícita existente es que los mensajes a leer están bien escritos. Otra arista de cambio para la aplicación es poder soportar un cierto nivel de errores tipográficos en nuestra fuente cruda de datos.
\end{itemize}

\paragraph{Productos soportados}
Inicialmente la aplicación tendrá soporte para una cantidad limitada de productos, enfocándose principalmente en aquellos de primera necesidad. La misma debe ser suficientemente flexible para poder cambiar estos productos. 

\paragraph{Ubicación}
La aplicación debe informar el lugar donde puede comprarse el producto al precio establecido. Inicialmente esta información deberá estar presente en el mismo \emph{tweet} en formato de 'calle y altura'. Conciendo que \textbf{twitter} permite agregar como información del \emph{tweet} la posición geográfica del mismo, la misma podría utilizarse en reemplazo del texto explicitando la dirección. Se espera que la aplicación pueda usar estos datos. 

Por otra parte, es importante tener en cuenta que, de agregarse nuevas fuentes de datos a la aplicación, estas deben ser capaces de indicar dónde se consigue el producto al precio publicitado.

\paragraph{Resumen de la información}
Dentro de la definición de la aplicación se establece que debe permitírsele al usuario especificar como la información será tratada. En esto se definen las siguientes características.

\begin{itemize}
  \item \textbf{Resumen:} Dentro de la masividad de datos que tendremos para un producto, es necesario definir cómo estos se resumirán para el usuario. En primer lugar, se deben poder priorizar los precios más baratos. Además se definen otras estrategias para tratar los datos, como ser \emph{caminando lo menos posible}. El sistema debe permitir agregar nuevas estrategias fácilmente.
  \item \textbf{Filtrado:} Otra posibilidad de tratamiento de datos que se le ofrece al usuario es el filtrado de los mismos. En este momento se presentan dos filtros: por zona geográfica y por rango de precios. El sistema debe soportar agregar nuevos criterios fácilmente.
  \item \textbf{Productos:} En esta primera instancia de la aplicación se está poniendo como restricción que el usuario pueda elegir un solo producto para buscar. En la versión final, la aplicación debe permitirle hacer búsquedas de varios productos a la vez.
\end{itemize}

\paragraph{Veracidad de los datos} A pesar del supuesto donde los datos provistos por redes sociales son imparciales, esto no nos asegura que los datos sean siempre correctos. Es importante tener en cuenta que los precios suben o que algún precio reportado puede ser una oferta temporal. Para tratar con estas complejidades se decidió que el sistema podrá incorporar en un futuro una forma de especificar la vigencia del precio en caso de ser una oferta. En una primera instancia, la aplicación se compromente a utilizar solo datos que tengan una frescura suficiente de forma que puedan considerarse correctos.

Otra propuesta para esta temática es incrementar la interacción con el usuario y que este pueda votar o reportar las ofertas provistas según si fueron buenas o no. Este tipo de información nos permitiria eliminar datos falsos o desactualizados.

\paragraph{Presentación de los datos}
La visualización de ofertas que se le dará al usuario no se encuentra completamente definida en esta instancia, es por ello que el diseño del sistema debe ser capaz de adaptarse a distintas propuestas que puedan surgir en el mediano plazo. Una propuesta ya presente es que la aplicación incorpore la información de precios en un mapa.


\section{User Stories}

\include{stories}

\section{Diseño}

La aplicación desarrollada se descompone en dos componentes, un \emph{Frontend}, a través del cuál el usuario accede a los servicios del sistema y se le presenta la información; y un \emph{Backend}, que a partir de una entrada del usuario, construye un resultado y se lo comunica al Frontend. En las siguientes secciones pasaremos a presentar el diseño del sistema.

\subsection{Diagramas de clases}
  
A continuación detallaremos el diseño del Frontend. Dado que nos encontramos en la primer iteración del proceso de desarrollo, el foco se concentró en proveer una interfaz clara para comunicar el Frontend con el Backend, y no una implementación completa de la capa de presentación de los datos.

La clase \textbf{WebFrontend} es la encargada de la presentación de los datos. Esta clase posee un único método utilizado por la librería \emph{CherryPy} para la presentación al usuario. La capa de presentación de los datos se encuentra suficientemente desacoplada de la capa de comunicación con el Backend, de forma que puede cambiarse por completo la primera, sin afectar el resto de funcionamiento.

La clase \textbf{OfferBackend} representa al Backend de la aplicación, con el cual el Frontend se comunica. Se decidió que esta clase debe ser \emph{abstracta} debido a que podrían haber varios métodos de comunicación con el Backend (Por ejemplo, mediante un servicio REST, de forma local, etc...). Son las subclases de OfferBackend las encargadas de definir esta cuestión. Un caso particular de esto es \textbf{OfferRestBackend}, que utiliza REST para comunicarse con el Backend. 

La clase \emph{RestCommunicator} provee una interfaz con la cual comunicarnos con un servicio REST como el implementado. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/frontend_class.jpg}
\caption{Frontend}
\end{figure}
\newpage


\subsubsection{Obtenci\'on, traducci\'on y filtrado de datos}
La clase \textbf{ModelManager} es la parte del sistema que se encarga de procesar la query (ya transformada) del usuario. Es entonces parte de la interfaz provista a nuestro backend para procesar querys. Su nombre se desprende por su interacción tanto con sus colaboradores internos, como sus parámetros que genera a nivel de gráfico de clases una forma de estrella.

Un eje de cambio que tuvimos en consideración y se ve reflejado en el diagrama es la posibilidad de tener más de una fuente de datos similar a \emph{Twitter}. Esto es, que la informaci\'on se pida cada vez con un request al proveedor de datos.

Otro eje de cambio est\'a en la interfaz \emph{iterable} fácilmente reemplazable por cualquier tipo de almacenamiento de datos que provea una manera de iterarlos. En siguientes versiones del programa podría utilizarse algún mecanismo de persistencia que ayude a eliminar el costo de hacer el request a nuestros conectores cada vez y la clase \textbf{OfferFactory} no deberia modificarse. Si es el caso de \textbf{DataManager} que deberá cambiar dada su dependencia con la obtenci\'on de los datos.

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{graphics/model_manager_iterable_class.jpg}
\caption{Model Manager Iterable}
\end{figure}



\newpage
Para pasar de los \emph{tweets} (u otro medio, ya que en este punto es transparente el origen de la información) a ofertas entendibles en nuestro sistema, implementamos un \textbf{OfferFactory} el cual es capaz de transformar una lista de \emph{tweets} (válidos o no) en una lista de ofertas válidas.

Para esto el OfferFactory es inicializado con un \textbf{ParserChain} que se encarga de intentar parsear la información de los \emph{tweets} devolviendo como resultado un \textbf{OfferBuilder} o la excepción  \textbf{ParserError} en caso de no ser posible para el parser extraer la información para rellenar el \textbf{OfferBuilder}.

El ParserChain es inicializado con una lista de \textbf{SpecificParser}, los cuales son llamados en el órden en el que vienen en la lista, tratando de extraer la información que necesitan y volcándola dentro del OfferBuilder que se está rellenado.

Este diseño nos da gran flexibilidad para los cambios futuros, tanto en agregar nuevas formas de extraer datos, como alterar la forma en la que se extraen algunos ahora sin modificar la extracción de otros. Por ejemplo, sería muy fácil agregar un validador ortográfico para poder detectar productos mal escritos sin necesidad de alterar ninguna otra parte (en el diseño se muestra una clase tentativa que le agrega a \textbf{ProductParser}). Lo mismo se aplica con la posibilidad de agregar validaciones a la \textbf{Location} la cual por el momento solo consiste en un string que no tiene ningún tipo de chequeo sobre su validez.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{graphics/parser_class.jpg}
\caption{Offer Factory}
\end{figure}
\begin{landscape}

\newpage
En este diagrama se destacan las clases de objetos que se encargan de, dada una \textbf{OfferQueryInConstruction} (Objeto que representa una consulta por ofertas sin procesar), construir el conjunto de restricciones a aplicar sobre las ofertas. Son los objetos de tipo \textbf{QueryProcessor} los encargados de construir los \textbf{Filter} y \textbf{Strategy} que determinan cuales serán los resultados finales de la consulta. En caso de que alguno de los parametros introducidos por el usuario no sean válidos, el \textbf{QueryProcessor} correspondiente informará de esta situación mediante una excepción. La clase \textbf{QueryProcessor} y sus subclases, siguen el patron de diseño \emph{Composite}.

Los objetos de tipo \textbf{ValidProductsProvider} llevan cuenta de cuales son los productos válidos. Un objeto de este tipo es utilizado por un \textbf{ProductQueryProcessor} para verificar que el producto ingresado por el usuario se encuentre en la lista de los productos soportados por el sistema.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{graphics/queryProcessor_class.jpg}
\caption{Query Processor}
\end{figure}

\newpage
Como fue mencionado anteriormente, un objeto de tipo \textbf{OfferQueryInConstruction} representa una query del usuario, la cual todavía no se terminó de procesar. Una vez que se terminaron de construir los filtros y estrategias correspondientes a la consulta del usuario, es necesario hacerla inmutable, obteniendo así un objeto con tipo \textbf{OfferQuery}. Los objetos de esta clase poseen únicamente un \textbf{Filter} y una \textbf{Strategy}.

Las \textbf{Strategy} representan distintas politicas para priorizar ofertas, por ejemplo, \emph{Mas baratas primero}. Los \textbf{Filter} representan condiciones booleanas que deben cumplir las ofertas para poder encontrarse en el conjunto de resultado. La clase \textbf{Filter} cumple con el patron de diseño \emph{Composite}. La clase \textbf{MultiFilter} sigue el patrón \emph{TemplateMethod}, esta clase define un esqueleto para la función \emph{filter}, sin embargo, son las clases derivadas las que implementan los metodos \emph{reduceOp} y \emph{baseCase}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/filter_class.jpg}
\caption{Filters and Strategies}
\end{figure}

\end{landscape}
\newpage
\subsection{Obtenc\'ion de datos extra}
Durante el transcurso del trabajo vimos que existen varias formas de conseguir informacion desde \emph{Twitter} asi como varias maneras de almacenarla. En el siguiente diagrama ilustramos una opci\'on para diseñar los mismos.

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{graphics/model_manager_storeObject_class.jpg}
\caption{Model Manager StoreObject}
\end{figure}

\newpage

\begin{landscape}
\subsection{Diagramas de secuencias}

El diagrama de secuencias debajo presenta el comportamiento global del \textbf{Backend}, iniciado por el mensaje \emph{query} recibido por la \textbf{RestApi}, clase que se encarga de la comunicación con el exterior. Esta clase sabe traducir desde y hacia el lenguaje externo, en este caso el protocolo \textsf{Rest} yl el lenguaje \textsf{Json}. La funcionalidad luego de la misma es recibir el mensaje en formato \emph{rest}, convertirlo en una \emph{query} de nuestro modelo llamando a un \textsf{QueryProcessor}, para así obtener una \textsf{OfferQuery}. Esta \textsf{OfferQuery} se le pasa al \textsf{ModelManager} que nos devolverá el resultado deseado y que \textsf{RestApi} se encargará de traducir al lenguaje utilizado en el exterior de la aplicación.
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{graphics/service_sequence.jpg}
\caption{Service}
\end{figure}
\end{landscape}

\newpage

En el siguiente diagrama se presenta el diagrama de secuencia para un \textbf{AndFilter}, que posee como colaborador a un \textbf{ProductFilter} y un \textbf{PriceRangeFilter}. Un \textbf{AndFilter} es un filtro que da su aprobación cuando todos los filtros contiene internamente también dan su aprobación. La interacción que se captura en este diagrama es la del mensaje \emph{filter} con \emph{anOffer} pasada como parámetro, a un \textbf{AndFilter}. El método asociado a este mensaje está implementado en \textbf{MultiFilter}. 

 Este método envia los mensajes \emph{baseCase} y \emph{reduceOp} a sí mismo. Los métodos asociados a estos mensajes están implementados en \textbf{AndFilter}. \emph{baseCase} es utilizado para inicializar un acumulador interno, mientras que \emph{reduceOp} se aplica a este acumulador y al resultado de aplicar cada filtro.
\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{graphics/andFilter_sequence.jpg}
\caption{andFilter}
\end{figure}
\begin{landscape}
\newpage
En este diagrama se muestra el envío del mensaje \emph{createOffers} a un \textbf{OfferFactory} pasándole como parámetro un objeto Iterable, este almacena un conjuntos de objetos del tipo \textbf{RawInfo} los cuales pueden ser pedidos uno tras otro utilizando el mensaje \emph{next}. \\

En este caso particular el objeto Iterable va a contar con dos elementos en su interior, de los cuales el primero es un dato válido ya que el objeto RawInfo contiene un text parseable por el sistema(ej: "Leche a 5 p el lt en varela al 20 $#$precioJusto"), mientas que el segundo contiene información no parseable(ej: "los mejores productos $#$precioJusto").
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{graphics/OfferFactory_sequence.jpg}
\caption{Offer Factory}
\end{figure}

\end{landscape}

\section{Primera Iteración}

En un esquema de desarrollo iterativo incremental, el producto final se construye en iteraciones. En cada iteración se establecen ciertos objetivos, que apuntan a agregar una nueva funcionaliad al producto. Para el momento de este informe, se desarrolló solo la primera iteración. En la misma, el objetivo definido fue tener una primera versión de la aplicación con una funcionalidad limitada, pero completa frente al espíritu del proyecto. El resultado de una iteración se denomina \emph{product increment} y deberá permitir buscar las ofertas de un producto en \emph{twitter}, filtrarlos con algún criterio y priorizalos mediante alguna estrategia.

A continuación explicamos cómo resulto el desarrollo de la primera iteración.

\subsection{Desarrollo}

En el ámbito del trabajo que se está realizando, es importante remarcar el hecho que el desarrollo iterativo incremental de la aplicación fue en el marco de un trabajo práctico cuyos objetivos exceden (e incluso son conflictivos con) los objetivos normales de una iteración. Es así que el trabajo se dividió en dos aristas: la de \emph{diseño orientado a objetos} y la de \emph{desarrollo del increment}. 

Lo primero que se hizo fue definir los requerimientos y el alcance de la aplicación al generar el \emph{Product Backlog}, cuyas historias detallarían estas decisiones. Luego surgió la necesidad de enfocarnos completamente en el diseño de la aplicación, lo que conformaba un punto muy importante del trabajo práctico. Esta sección de trabajo entra en conflicto con la metodología de desarrollo ya que en la misma la visibilidad completa del diseño no solo no es importante sino que debe postergarse para extenderse y corregirse contínuamente con las iteraciones. A razón de este trabajo inicial de diseño el desarrollo quedó en segundo plano hasta la segunda mitad del \emph{sprint}, como puede verse en el \textbf{burndown chart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{graphics/iteration_burndown.pdf}
\caption{\textbf{Burndown chart:} progreso de terminación de tareas en el \emph{sprint}.}
\end{figure}

Una vez contentos con el porcentaje de diseño realizado para los fines del trabajo práctico, el desarrollo de código adquirió prioridad. Considerando que los integrantes del equipo, teniendo otras responsabilidades, no podían dedicarse diariamente al proyecto, puede observarse en el gráfico que los días de trabajo están espaciados. Las actividades de finalización de tarea fueron bastante postergadas, por lo que la cantidad de historias aceptadas creció abrúptamente en los últimos días.

\subsection{Logros}

El primer \emph{product increment} se enfocó en lograr una primera prueba de un sistema funcionando completamente. Su desarrollo se orientó a que hubiera algo para presentar al \emph{Product Owner} y al usuario final, así como para que fuera fácilmente expansible a los ejes de cambio definidos. Entre las funcionalidades básicas logradas se encuentran:

\begin{itemize}
  \item Un frontend web que permite simple usabilidad para el usuario.
  \item Consulta a \emph{twitter} de tweets con hashtag \textbf{\#PrecioJusto} para obtener precios de productos.
  \item Interpretación de los \emph{tweets} para obtener la información.
  \item Priorización de los menores precios encontrados para un producto.
  \item Filtrado de los precios acorde a un mínimo y máximo.
\end{itemize}

\subsection{Revisión}

Al finalizar el \emph{sprint} realizamos una revisón sobre cómo trabajó el equipo y qué mejoras podrían hacerse. Llegamos a las siguientes conclusiones. 

\begin{itemize}
  \item \textbf{Poca comunicación con el PO:} a lo largo del \emph{sprint}, la falta de comunicación con el \textbf{Product Owner} originó muchas sorpresas en cuanto a requerimientos y expectativas tanto del desarrollo del \emph{increment} como del trabajo práctico. En futuras iteraciones es recomendable reunirse con el \textbf{Product Owner} con mayor frecuencia.
  \item \textbf{Seguimiento espaciado del proyecto:} a causa de otras responsabilidades y distracciones, las horas dedicadas al desarrollo estuvieron espaciadas y la mayor parte del trabajo se concentró en unos pocos días. En el futuro es recomendable una mayor frecuencia de trabajo de forma que los desvíos y las dudas puedan resolverse con mayor velocidad.
  \item \textbf{Poco asado:} evidentemente el trabajo del equipo se vio afectado por la falta de asado en las reuniones, que bajó la moral y denigró el espíritu de trabajo. En las próximas iteraciones la bondiola y vacío serán protagonistas.
  \item \textbf{Disparidad en la formación de los integrantes:} a causa de las distintas experiencias y líneas de trabajo de cada uno de los integrantes, nos encontramos con diferencias en la experiencia con las herramientas y variedad de forma de pensar las problemáticas. En el futuro será importante tener en cuenta que es necesario dedicarle más atención a cómo comunicamos las ideas dentro del equipo, así como equiparar mejor el conocimiento de las tecnologías.
\end{itemize}



\end{document}
